# Modified script per user request
# Only collect processes matching schematic AND username,
# Do not gather all processes.
# If any match found → print and exit.
# If none → print "No matching processes found" and exit.

param(
    [string]$InputPath  = "servers.txt",
    [bool]  $DryRun      = $false,
    [pscredential]$Credential = $null
)

function Write-Log {
    param([string]$Message,[string]$Level="INFO")
    $timestamp = (Get-Date).ToString("yyyy-MM-dd HH:mm:ss,fff")
    Write-Host "$timestamp - [$Level] $Message"
}

function Test-IsIPAddress { param([string]$Text) $addr=$null; return [Net.IPAddress]::TryParse($Text,[ref]$addr) }
function Normalize-MachineName {
    param([string]$Raw)
    $hostPart = $Raw -replace '^.*\\',''
    if (Test-IsIPAddress $hostPart) { return $hostPart }
    if ($hostPart -match '\.') { return $hostPart }
    try {
        $dns = Resolve-DnsName -Name $hostPart -ErrorAction Stop | Where-Object { $_.QueryType -in 'A','CNAME' }
        return ($dns | Select-Object -First 1).Name
    } catch { return $hostPart }
}

function New-TargetCimSession {
    param([string]$ComputerName,[pscredential]$Cred)
    $isIP = Test-IsIPAddress $ComputerName
    if (-not $isIP) {
        try {
            $wsOpt = New-CimSessionOption -Protocol Wsman
            if ($Cred) { return New-CimSession -ComputerName $ComputerName -Credential $Cred -SessionOption $wsOpt }
            else       { return New-CimSession -ComputerName $ComputerName -SessionOption $wsOpt }
        } catch {}
    }
    $dcOpt = New-CimSessionOption -Protocol Dcom
    if ($Cred) { return New-CimSession -ComputerName $ComputerName -Credential $Cred -SessionOption $dcOpt }
    else       { return New-CimSession -ComputerName $ComputerName -SessionOption $dcOpt }
}

# Read input
ttry {
    $lines = Get-Content -LiteralPath $InputPath -ErrorAction Stop
} catch {
    Write-Log "Unable to read input file: $($_.Exception.Message)" "ERROR"
    exit 1
}

$entries = foreach ($line in $lines) {
    if ([string]::IsNullOrWhiteSpace($line)) { continue }
    $p = $line.Trim() -split '\s+'
    if ($p.Count -lt 3) { continue }
    [pscustomobject]@{
        SCHEMATIC = $p[0]
        OSUSER    = $p[1]
        MACHINE   = Normalize-MachineName $p[2]
    }
}

foreach ($e in $entries) {

    Write-Log "Processing $($e.MACHINE) for user $($e.OSUSER) and schematic $($e.SCHEMATIC)"
    $sess = $null

    try {
        $sess = New-TargetCimSession -ComputerName $e.MACHINE -Cred $Credential
        if (-not $sess) { Write-Log "CIM session failed" "ERROR"; exit 1 }

        # ----------------------
        # **NEW LOGIC HERE – UPDATED** (Only username + process name match)
        # We do NOT check CommandLine now.
        # We ONLY check:
        #   1. Owner username == OSUSER
        #   2. ProcessName == schematic (case-insensitive)

        $schemLower = $e.SCHEMATIC.ToLower()

        $matching = Get-CimInstance Win32_Process -CimSession $sess |
            Where-Object {
                # Process name match (without .exe)
                ($_.Name.ToLower() -replace '\.exe$','') -eq $schemLower -and 
                # User match
                (
                    (Invoke-CimMethod -InputObject $_ -MethodName GetOwner -CimSession $sess -ErrorAction SilentlyContinue).User -eq $e.OSUSER
                )
            }**
        # Gather ONLY ompplus-name processes that match schematic + user
        # Not ALL processes
        # ----------------------

        $matching = Get-CimInstance Win32_Process -CimSession $sess |
            Where-Object {
                $_.CommandLine -match [regex]::Escape($e.SCHEMATIC) -and (
                    (Invoke-CimMethod -InputObject $_ -MethodName GetOwner -CimSession $sess -ErrorAction SilentlyContinue).User -eq $e.OSUSER
                )
            }

        if ($matching.Count -gt 0) {
            Write-Host "MATCH FOUND:" -ForegroundColor Green
            $matching | ForEach-Object {
                $o = Invoke-CimMethod -InputObject $_ -MethodName GetOwner -CimSession $sess
                Write-Host "PID: $($_.ProcessId)  USER: $($o.User)  CMD: $($_.CommandLine)"
            }
            exit 0
        }
        else {
            Write-Host "No matching processes found on $($e.MACHINE)" -ForegroundColor Yellow
            exit 0
        }
    }
    catch {
        Write-Log "Error: $($_.Exception.Message)" "ERROR"
        exit 1
    }
    finally {
        if ($sess) { Remove-CimSession $sess }
    }
}
