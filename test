# Check-Processes-PerName-Fixed.ps1
# For each process name in $ProcessNames:
#  - find processes whose Name contains that token on the remote server
#  - for each found process, verify Owner (username) and CommandLine (schema)
#  - print every match

$Server       = "AWSDROIRLW0009"
$TargetUser   = "SA-ITS-APSPHINT-DEV1"
$SchemaPrefix = "JNJ_PH_OLY_DEV_604"

# Processes to check (add or remove names here)
$ProcessNames = @("ompplus","sapintegrator1","scintegrator","ompeditor")

Write-Host "Checking processes one-by-one on $Server for user '$TargetUser' and schema '$SchemaPrefix'..." -ForegroundColor Cyan

try {
    $allMatches = @()

    foreach ($token in $ProcessNames) {
        Write-Host "`nSearching for processes matching token '$token' ..." -ForegroundColor Cyan

        # Query remote for processes whose Name contains the token (case-insensitive)
        $candidates = Invoke-Command -ComputerName $Server -ScriptBlock {
            param($t)
            Get-WmiObject Win32_Process -ErrorAction Stop |
                Where-Object { $_.Name -and ($_.Name -ilike "*$t*") } |
                ForEach-Object {
                    $owner = $_.GetOwner()
                    [PSCustomObject]@{
                        SearchToken  = $t
                        ProcessId    = $_.ProcessId
                        Name         = $_.Name
                        CommandLine  = $_.CommandLine
                        OwnerUser    = if ($owner) { $owner.User } else { $null }
                        OwnerDomain  = if ($owner) { $owner.Domain } else { $null }
                        CreationDate = $_.CreationDate
                    }
                }
        } -ArgumentList $token -ErrorAction Stop

        if (-not $candidates) {
            Write-Host "  No processes found for token '$token'." -ForegroundColor Yellow
            continue
        }

        # For each candidate, verify the username and schema prefix
        foreach ($proc in $candidates) {
            $ownerFull = if ($proc.OwnerDomain -and $proc.OwnerUser) { "$($proc.OwnerDomain)\$($proc.OwnerUser)" } else { $proc.OwnerUser }

            # Username match: allow either exact user or appearing as substring (case-insensitive)
            $userMatches = $false
            if ($proc.OwnerUser) {
                if ($proc.OwnerUser -ieq $TargetUser) { $userMatches = $true }
                elseif ($ownerFull -and ($ownerFull -ilike "*$TargetUser*")) { $userMatches = $true }
            }

            # CommandLine match: contains schema prefix (case-insensitive)
            $cmdMatches = ($proc.CommandLine -and ($proc.CommandLine -ilike "*$SchemaPrefix*"))

            if ($userMatches -and $cmdMatches) {
                $allMatches += $proc

                Write-Host "`nProcess matched (token: $($proc.SearchToken)):" -ForegroundColor Green
                Write-Host "   PID         : $($proc.ProcessId)"
                Write-Host "   Name        : $($proc.Name)"
                Write-Host "   User        : $ownerFull"
                Write-Host "   Started On  : $($proc.CreationDate)"
                Write-Host "   CommandLine : $($proc.CommandLine)"
            }
        }
    }

    if (-not $allMatches) {
        Write-Host "`nNo jobs found matching the user and schema for any of the process tokens." -ForegroundColor Yellow
        exit 0
    }

    Write-Host "`nSummary: $($allMatches.Count) matching process(es) found." -ForegroundColor Cyan
}
catch {
    Write-Host "Error connecting to server or fetching process: $($_.Exception.Message)" -ForegroundColor Red
    exit 1
}

exit 0
